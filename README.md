# ProtobufKMM

This is (will be) a set of protoc plugins to generate code for using
[grpc](https://grpc.io) and
[protobuf](https://developers.google.com/protocol-buffers) in
[Kotlin Multiplatform Mobile](https://kotlinlang.org/lp/mobile/).

I couldn't get
[GRPC-Kotlin-Multiplatform](https://github.com/TimOrtel/GRPC-Kotlin-Multiplatform)
to work, so I decided to write an alternative. It's based on a set of
stand-alone protoc plugins to avoid the complexity of gradle which seems to be
the main cause of the problems in GRPC-Kotlin-Multiplatform.

For the sake of getting up and running quickly, this still relies on existing
implementations for Android and iOS, using
[grpc-swift](https://github.com/grpc/grpc-swift) on the latter. This is because
I don't know Objective-C, and because I don't want to have to use Cocoapods.

## Implementation

It's very simple, you just need python3 and the protobuf package, which is
available with pip or most package managers. Rather than install anything you
can include the path to the python scripts in your protoc invocations using the
`--plugin` option eg:
`--plugin="$HOME/Code/ProtobufKMM/protoc-gen-kmm-data"`.

## The protoc plugins

### Common options and parameters

The plugins that generate Kotlin code require a Kotlin package name. This can
be provided as a `kmm_package` parameter in the protoc command line eg:
`--kmm-kmm-data_opt=kmm_package='org.example.proto.kmm'`. If not given, it
defaults to `java_package.kmm` where `java_package` is read from the option of
that name in the proto file. `kmm_package` must be different from `java_package`
to prevent name clashes.

The plugins that generate Swift code require the name of your project's shared
module. If it is not called `shared`, its name must be passed as a parameter in
the protoc invocation, eg
`--kmm-swift-conv_opt=shared_module='MySharedModuleName'`.

### protoc-gen-kmm-data

Generates Kotlin data classes and enum classes for the protobuf messages and
enums. Designed to be used in your shared module with minimum fuss. This
outputs one file per message/enum.

### protoc-gen-kmm-jvm-conv

Generates Kotlin class extensions in the Android module which convert the
simple data classes and enums generated by the kmm-data plugin to and from
their Kotlin/JVM counterparts. Each class in the JVM implementation is extended
with a `toData` instance method and each portable data class and enum is
extended with a `toProto` instance method.

The output filenames are the same as for `protoc-gen-kmm-data`. They shouldn't
clash because each generator outputs to a different module. These files
belong in `java_package`, not `kmm_package`.

### protoc-gen-kmm-swift-conv

Generates Swift class extensions in the Xcode project which convert the
simple data classes and enums generated by the kmm-data plugin to and from
their Swift counterparts.

The output filename is `ProtoPackageConverters.swift`.

### protoc-gen-kmm-grpc-shared

Generates an interface for each service in the shared module which encapsulates
all the rpc methods in the proto file, using suspend functions, Flows and the
kmm-data types. Each interface is named `QualifiedServiceGrpcClient`. If there
is only one service in the proto file and they both have the same name,
`QualifiedService` == `ProtoPackage` == `ServiceName`, otherwise
`QualifiedService` stands for `ProtoPackageServiceName`.

### protoc-gen-kmm-grpc-android

Generates classes in the Android module implementing the above GrpClient
interfaces, converting the data types to and from their JVM implementation
counterparts. Where entity names have a suffix of `GrpcClient` above, the
Android implementations have a suffix of `GrpcAndroidClient`.

The class constructor takes a parameter
`private val stub: QualifiedServiceCoroutineStub`, which is an instance of a
class defined in the output from the upstream grpc-kotlin code generator. You
are responsible for instantiating the stub.

### protoc-gen-kmm-grpc-ios-main

Generates files in the `iosMain` part of the shared module:

* `ProtoPackageGrpcIosClient.kt`: Kotlin native/iOS class(es) implementing
`QualifiedServiceGrpcClient`. It uses `GrpcIosClientHelper` to bridge between
Kotlin's coroutines and flows and a callback-based API implemented by
`QualifiedServiceGrpcIosDelegate`.

* `ProtoPackageGrpcIosDelegate.kt`: Kotlin interface(s) for callback-based
versions of each service's API. `QualifiedServiceGrpcIosClient` delegates to an
instance of `QualifiedServiceGrpcIosDelegate`. The latter is implemented in
Swift and uses grpc-swift.

* `GrpcIosClientHelper.kt`: An object which can be used for all and any Grpc
services. It contains a generic interface and methods to bridge between
`QualifiedServiceGrpcIosClient` and `QualifiedServiceGrpcIosDelegate` for each
type of rpc call (unary, client-streaming, server-streaming,
bidirectional-streaming).

### protoc-gen-kmm-grpc-swift

Generates `ProtoPackageGrpcIosDelegate.swift` in the Xcode project. It contains
a class for each service called `QualifiedServiceGrpcIosDelegate`. These classes
are the implementations of the delegate interfaces generated by
`protoc-gen-kmm-grpc-ios-main`. Each constructor takes a `client` parameter of
`ProtoPackage_ServiceNameClientProtocol`. This will usually be an instance of
`ProtoPackage_ServiceNameNIOClient` (as opposed to `...AsyncClient`).

If your project's shared module is not called `shared`, its name must be passed
as an option in the protoc invocation, eg
`--kmm-grpc-swift_opt=shared_module='MySharedModuleName'`.

## Limitations

This set of plugins was written to support a specific app, which needs to be
completed ASAP. I don't have time to work on protobuf features it doesn't use,
which include:

* gRPC servers
* Nested messages and enums (might work, but not tested).
* Includes.
* Extensions.
* `oneof` types

So these plugins will generate incorrect code for them.

Also, bidirectional streaming methods are untested.

However, this code is sufficiently simple and well-documented that I think a
third party wouldn't find it too difficult to add/fix those features if they
need them.

### Adding Swift files to your XCode project

The first time you create any Swift files you will have to manually add them to
your XCode project by dragging them from Finder, even if they are created in
the correct location.

## Licence

ISC. See [LICENSE](LICENSE).
