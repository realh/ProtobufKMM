#!/usr/bin/env python3

import os.path
import sys

from google.protobuf.compiler.plugin_pb2 import \
    CodeGeneratorRequest, CodeGeneratorResponse

from google.protobuf.descriptor_pb2 import \
    FileDescriptorProto, \
    EnumDescriptorProto, DescriptorProto, \
    ServiceDescriptorProto, MethodDescriptorProto

from generator import Generator

class KMMGrpcIosHelperGenerator(Generator):
    ''' Generates GrpcIosClientHelper.kt by copying the template file. '''
    def __init__(self, namespace: str, options: dict[str, str]):
        super().__init__(baseName="kmm-grpc-ios-main")
        self.namespace = namespace
        self.options = options

    def process(self, req: CodeGeneratorRequest) -> CodeGeneratorResponse:
        ''' We only want to create one GrpcIosClientHelper. This generator must
            be run last. '''
        req.proto_file = [req.proto_file[0]]
        return super().process(req)

    def getContent(self, protoFile: FileDescriptorProto) -> str:
        inputName = os.path.join(os.path.dirname(sys.argv[0]),
                                 "GrpcIosClientHelper.kt")
        f = open(inputName, "r")
        template = str(f.read())
        f.close()
        package = self.options.get("java_package")
        if package is not None:
            template = template.replace("package org.example.proto",
                                        "package " + package)
        return template

    def getOutputFileName(self, protoFileName: str, packageName: str) -> str:
        return "GrpcIosClientHelper.kt"

    
class KMMGrpcIosDelegateGenerator(Generator):
    ''' Generates the Kotlin interface for the delegate which is actually
        implemented in Swift. '''
    def __init__(self, namespace: str, options: dict[str, str]):
        super().__init__(baseName="kmm-grpc-ios-main")
        self.namespace = namespace
        self.options = options
    
    def getOutputFileName(self, protoFileName: str, packageName: str) -> str:
        return self.typeNameCase(packageName) + "GrpcIosDelegate.kt"

    def processEnum(self, enum: EnumDescriptorProto,
                    indentationLevel: int) -> list[str]:
        return []

    def processMessage(self, msg: DescriptorProto,
                       indentationLevel: int) -> list[str]:
        return []

    def getHeader(self, protoFile: FileDescriptorProto) -> list[str]:
        return [
            "package " + self.options["java_package"],
            "",
        ]
    
    def getFooter(self, protoFile: FileDescriptorProto) -> list[str]:
        return [""]
    
    def getServiceHeader(self, protoFile: FileDescriptorProto,
                         serv: ServiceDescriptorProto,
                         indentationLevel: int) -> list[str]:
        serviceName = self.getServiceName(protoFile, serv)
        return [
            "interface %sGrpcIosDelegate {" % serviceName
        ]

    def getServiceFooter(self, protoFile: FileDescriptorProto,
                         serv: ServiceDescriptorProto,
                         indentationLevel: int) -> list[str]:
        return ["}"]

    def getServiceMethod(self, protoFile: FileDescriptorProto,
                        serv: ServiceDescriptorProto,
                        method: MethodDescriptorProto,
                        indentationLevel: int) -> list[str]:
        return self.getMethodSignature(
            protoFile,
            serv,
            method,
            indentationLevel,
            withCallbacks=True
        ) + [""]

    def getReturn(self, protoFile: FileDescriptorProto,
                  method: MethodDescriptorProto) -> list[str]:
        return self.getResultCallbackInLieuOfReturn(protoFile, method)
    
    def getSuspendKeyword(self) -> str:
        # Can't use suspend in Kotlin-Swift bridge
        return ""
        

class KMMGrpcIosClientGenerator(Generator):
    ''' Generates the GrpcIosClient (Kotlin, implementing the shared interface).
    '''
    def __init__(self, namespace: str, options: dict[str, str]):
        super().__init__(baseName="kmm-grpc-ios-main")
        self.namespace = namespace
        self.options = options
    
    def processMessagesAndEnums(self, protoFile: FileDescriptorProto,
                                response: CodeGeneratorResponse):
        pass
    
    def getOutputFileName(self, protoFileName: str, packageName: str) -> str:
        return self.typeNameCase(packageName) + "GrpcIosClient.kt"

    def getHeader(self, protoFile: FileDescriptorProto) -> list[str]:
        pkg = self.options["java_package"]
        importHelper = "import %s.GrpcIosClientHelper" % pkg
        return [
            "package " + pkg,
            "",
            "import kotlinx.coroutines.flow.Flow",
            importHelper + ".unaryCall",
            importHelper + ".serverStreamingCall",
            importHelper + ".clientStreamingCall",
            importHelper + ".bidirectionalStreamingCall",
            "",
        ]
    
    def getFooter(self, protoFile: FileDescriptorProto) -> list[str]:
        return [""]
    
    def getServiceHeader(self, protoFile: FileDescriptorProto,
                         serv: ServiceDescriptorProto,
                         indentationLevel: int) -> list[str]:
        serviceName = self.getServiceName(protoFile, serv)
        indent = "    " * indentationLevel
        return [
            indent + "class %sGrpcIosClient (" % serviceName,
            indent + "    private val delegate: %sGrpcIosDelegate" % \
                serviceName,
            indent + "): %sGrpcClient {" % serviceName,
        ]

    def getServiceFooter(self, protoFile: FileDescriptorProto,
                         serv: ServiceDescriptorProto,
                         indentationLevel: int) -> list[str]:
        return ["}"]

    def getServiceMethod(self, protoFile: FileDescriptorProto,
                        serv: ServiceDescriptorProto,
                        method: MethodDescriptorProto,
                        indentationLevel: int) -> list[str]:
        indentationLevel += 1
        lines = self.getMethodSignature(protoFile,
                                        serv,
                                        method,
                                        indentationLevel,
                                        withCallbacks=False)
        indent = "    " * indentationLevel
        lines[0] = indent + "override " + lines[0][4:]
        lines[-1] += " = "
        methodName = self.memberCase(method.name)
        if method.client_streaming and method.server_streaming:
            lines[-1] += "bidirectionalStreamingCall(request) {"
            body = "delegate.%s(it)"
        elif method.client_streaming:
            lines[-1] += "clientStreamingCall(request) {"
            body = "delegate.%s(it)"
        elif method.server_streaming:
            lines[-1] += "serverStreamingCall {"
            body = "delegate.%s(request, it)"
        else:
            lines[-1] += "unaryCall {"
            body = "delegate.%s(request, it)"
        lines.append(indent + "    " + body % methodName)
        lines.extend([indent + "}", ""])
        return lines


class KMMGrpcIosMainGenerator(Generator):
    def __init__(self):
        super().__init__(baseName="kmm-grpc-ios-main")
    
    def processFile(self, protoFile: FileDescriptorProto,
                    response: CodeGeneratorResponse):
        self.options = self.getOptions(protoFile)
        self.namespace = self.getNamespace(protoFile)
        for generator in (
                KMMGrpcIosDelegateGenerator(self.namespace, self.options),
                KMMGrpcIosClientGenerator(self.namespace, self.options),
                KMMGrpcIosHelperGenerator(self.namespace, self.options),
        ):
            generator.processFile(protoFile, response)
    

def main():
    KMMGrpcIosMainGenerator().runOnStdinAndStdout()

if __name__ == "__main__":
    main()
