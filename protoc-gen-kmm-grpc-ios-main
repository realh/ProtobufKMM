#!/usr/bin/env python3

from google.protobuf.descriptor_pb2 import \
    FileDescriptorProto, \
    EnumDescriptorProto, DescriptorProto, \
    ServiceDescriptorProto, MethodDescriptorProto

from generator import Generator

class KMMGrpcIosDelegateGenerator(Generator):
    def __init__(self):
        super().__init__(baseName="kmm-grpc-ios-main")
    
    def getOutputFileName(self, protoFileName: str, packageName: str) -> str:
        return self.typeNameCase(packageName) + "IosGrpcDelegate.kt"

    def processEnum(self, enum: EnumDescriptorProto,
                    indentationLevel: int) -> list[str]:
        return []

    def processMessage(self, msg: DescriptorProto,
                       indentationLevel: int) -> list[str]:
        return []

    def getHeader(self, protoFile: FileDescriptorProto) -> list[str]:
        return [
            "package " + self.options["java_package"],
            "",
        ]
    
    def getFooter(self, protoFile: FileDescriptorProto) -> list[str]:
        return [""]
    
    def getTopLevelIndentation(self, protoFile: FileDescriptorProto) -> int:
        return 1

    def getServiceHeader(self, protoFile: FileDescriptorProto,
                         serv: ServiceDescriptorProto,
                         indentationLevel: int) -> list[str]:
        serviceName = self.getServiceName(protoFile, serv)
        return [
            "interface %sGrpcIosDelegate {" % serviceName
        ]

    def getServiceFooter(self, protoFile: FileDescriptorProto,
                         serv: ServiceDescriptorProto,
                         indentationLevel: int) -> list[str]:
        return ["}"]

    def getServiceMethod(self, protoFile: FileDescriptorProto,
                        serv: ServiceDescriptorProto,
                        method: MethodDescriptorProto,
                        indentationLevel: int) -> list[str]:
        if method.client_streaming:
            return self.getClientStreamingMethodSignature(
                protoFile,
                serv,
                method,
                indentationLevel,
            ) + [""]
        else:
            return self.getMethodSignature(
                protoFile,
                serv,
                method,
                indentationLevel,
            )

    def getClientStreamingMethodSignature(
        self, protoFile: FileDescriptorProto,
        serv: ServiceDescriptorProto,
        method: MethodDescriptorProto,
        indentationLevel: int,
    ) -> list[str]:
        # Server streaming methods don't need to be suspending
        if method.server_streaming:
            suspend = ""
        else:
            suspend = self.getSuspendKeyword()
        typeName = self.convertTypeName(method.input_type)
        inputType = self.getNamespace(protoFile) + "." + typeName
        ifName = self.getStreamerInterfaceName(protoFile, serv, typeName)
        resultCb = self.getResultCallback(protoFile, method)
        resultCb = ["   " + l for l in resultCb]
        # Note that in callback declarations Kotlin and Swift both use ->
        return ["    %s%s%s(" % (suspend,
                                 self.getFuncKeyword(),
                                 self.memberCase(method.name)
                                 ),
        ] + resultCb + [ "    )%s%s" % (self.getReturnSymbol(), ifName) ]
    
    def getReturn(self, protoFile: FileDescriptorProto,
                  method: MethodDescriptorProto) -> list[str]:
        return self.getResultCallbackInLieuOfReturn(protoFile, method)
    
    def getSuspendKeyword(self) -> str:
        # Can't use suspend in Kotlin-Swift bridge
        return ""
    

class KMMIosGrpcClientGenerator(Generator):
    def __init__(self):
        super().__init__(baseName="kmm-grpc-ios-main")
        self.hasUnary = False
        self.hasServerStream = False
        self.hasClientStream = False
        self.hasBidirectionalStream = False
    
    def getOutputFileName(self, protoFileName: str, packageName: str) -> str:
        return self.typeNameCase(packageName) + "IosGrpcClient.kt"

    def processEnum(self, enum: EnumDescriptorProto,
                    indentationLevel: int) -> list[str]:
        return []

    def processMessage(self, msg: DescriptorProto,
                       indentationLevel: int) -> list[str]:
        return []

    def getHeader(self, protoFile: FileDescriptorProto) -> list[str]:
        pkg = self.options["java_package"]
        importFlow = "import kotlinx.coroutines.flow."
        lines = [
            "package " + pkg,
            "",
            importFlow + "Flow",
            importFlow + "map",
            "",
        ]
    
    def getFooter(self, protoFile: FileDescriptorProto) -> list[str]:
        return [""]
    
    def getTopLevelIndentation(self, protoFile: FileDescriptorProto) -> int:
        return 0

    def getServiceHeader(self, protoFile: FileDescriptorProto,
                         serv: ServiceDescriptorProto,
                         indentationLevel: int) -> list[str]:
        serviceName = self.getServiceName(protoFile, serv)
        indent = "    " * indentationLevel
        return [
            indent + "class %sAndroidGrpcClient (" % serviceName,
            indent + "    val stub: %sCoroutineStub" % serv.name,
            indent + "): %sGrpcClient {" % serviceName,
        ]

    def getServiceFooter(self, protoFile: FileDescriptorProto,
                         serv: ServiceDescriptorProto,
                         indentationLevel: int) -> list[str]:
        return ["}"]

    def getServiceMethod(self, protoFile: FileDescriptorProto,
                        serv: ServiceDescriptorProto,
                        method: MethodDescriptorProto,
                        indentationLevel: int) -> list[str]:
        indentationLevel += 1
        lines = self.getMethodSignature(protoFile,
                                        serv,
                                        method,
                                        indentationLevel)
        indent = "    " * indentationLevel
        lines[0] = indent + "override " + lines[0][4:]
        lines[-1] += " ="
        methodName = self.memberCase(method.name)
        if method.client_streaming:
            input = "map { it.toProto() }"
        else:
            input = "toProto()"
        if method.server_streaming:
            output = "map { it.toData() }"
        else:
            output = "toData()"
        lines.extend([
            indent + "    stub.%s(request.%s).%s" % \
                (methodName, input, output),
            ""
        ])
        return lines

def main():
    generator = KMMGrpcIosDelegateGenerator()
    generator.runOnStdinAndStdout()

if __name__ == "__main__":
    main()
