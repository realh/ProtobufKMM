#!/usr/bin/env python3

import os.path
import sys

from google.protobuf.compiler.plugin_pb2 import \
    CodeGeneratorRequest, CodeGeneratorResponse

from google.protobuf.descriptor_pb2 import \
    FileDescriptorProto, \
    EnumDescriptorProto, DescriptorProto, \
    ServiceDescriptorProto, MethodDescriptorProto

from generator import Generator

class KMMGrpcIosHelperGenerator(Generator):
    ''' Generates GrpcClientHelper.kt by copying the template file. '''
    def __init__(self, namespace: str, options: dict[str, str]):
        super().__init__(baseName="kmm-grpc-ios-main")
        self.namespace = namespace
        self.options = options

    def process(self, req: CodeGeneratorRequest) -> CodeGeneratorResponse:
        ''' We only want to create one GrpcClientHelper. This generator must
            be run last. '''
        req.proto_file = [req.proto_file[0]]
        return super().process(req)

    def getContent(self, protoFile: FileDescriptorProto) -> str:
        inputName = os.path.join(os.path.dirname(sys.argv[0]),
                                 "GrpcClientHelper.kt")
        f = open(inputName, "r")
        template = str(f.read())
        f.close()
        package = self.options.get("java_package")
        if package is not None:
            template = template.replace("package org.example.proto",
                                        "package " + package)
        return template

    def getOutputFileName(self, protoFileName: str, packageName: str) -> str:
        protoFileName = protoFileName.replace(".proto", "")
        return self.typeNameCase(packageName) + "GrpcClientHelper.kt"

    
class KMMGrpcIosDelegateGenerator(Generator):
    ''' Generates the Kotlin interface for the delegate which is actually
        implemented in Swift. '''
    def __init__(self, namespace: str, options: dict[str, str]):
        super().__init__(baseName="kmm-grpc-ios-main")
        self.namespace = namespace
        self.options = options
    
    def getOutputFileName(self, protoFileName: str, packageName: str) -> str:
        return self.typeNameCase(packageName) + "IosGrpcDelegate.kt"

    def processEnum(self, enum: EnumDescriptorProto,
                    indentationLevel: int) -> list[str]:
        return []

    def processMessage(self, msg: DescriptorProto,
                       indentationLevel: int) -> list[str]:
        return []

    def getHeader(self, protoFile: FileDescriptorProto) -> list[str]:
        return [
            "package " + self.options["java_package"],
            "",
        ]
    
    def getFooter(self, protoFile: FileDescriptorProto) -> list[str]:
        return [""]
    
    def getTopLevelIndentation(self, protoFile: FileDescriptorProto) -> int:
        return 1

    def getServiceHeader(self, protoFile: FileDescriptorProto,
                         serv: ServiceDescriptorProto,
                         indentationLevel: int) -> list[str]:
        serviceName = self.getServiceName(protoFile, serv)
        return [
            "interface %sGrpcIosDelegate {" % serviceName
        ]

    def getServiceFooter(self, protoFile: FileDescriptorProto,
                         serv: ServiceDescriptorProto,
                         indentationLevel: int) -> list[str]:
        return ["}"]

    def getServiceMethod(self, protoFile: FileDescriptorProto,
                        serv: ServiceDescriptorProto,
                        method: MethodDescriptorProto,
                        indentationLevel: int) -> list[str]:
        if method.client_streaming:
            return self.getClientStreamingMethodSignature(
                protoFile,
                serv,
                method,
                indentationLevel,
            ) + [""]
        else:
            return self.getMethodSignature(
                protoFile,
                serv,
                method,
                indentationLevel,
            ) + [""]

    def getClientStreamingMethodSignature(
        self, protoFile: FileDescriptorProto,
        serv: ServiceDescriptorProto,
        method: MethodDescriptorProto,
        indentationLevel: int,
    ) -> list[str]:
        # Server streaming methods don't need to be suspending
        if method.server_streaming:
            suspend = ""
        else:
            suspend = self.getSuspendKeyword()
        typeName = self.convertTypeName(method.input_type)
        inputType = self.getNamespace(protoFile) + "." + typeName
        ifName = self.getStreamerInterfaceName(protoFile, serv, typeName)
        resultCb = self.getResultCallback(protoFile, method)
        resultCb = ["   " + l for l in resultCb]
        # Note that in callback declarations Kotlin and Swift both use ->
        return ["    %s%s%s(" % (suspend,
                                 self.getFuncKeyword(),
                                 self.memberCase(method.name)
                                 ),
        ] + resultCb + [ "    )%s%s" % (self.getReturnSymbol(), ifName)]
    
    def getReturn(self, protoFile: FileDescriptorProto,
                  method: MethodDescriptorProto) -> list[str]:
        return self.getResultCallbackInLieuOfReturn(protoFile, method)
    
    def getSuspendKeyword(self) -> str:
        # Can't use suspend in Kotlin-Swift bridge
        return ""
    

class KMMIosGrpcClientGenerator(Generator):
    ''' Generates the IosGrpcClient (Kotlin, implementing the shared interface).
    '''
    def __init__(self):
        super().__init__(baseName="kmm-grpc-ios-main")
    
    def getOutputFileName(self, protoFileName: str, packageName: str) -> str:
        return self.typeNameCase(packageName) + "IosGrpcClient.kt"

    def processEnum(self, enum: EnumDescriptorProto,
                    indentationLevel: int) -> list[str]:
        return []

    def processMessage(self, msg: DescriptorProto,
                       indentationLevel: int) -> list[str]:
        return []

    def getHeader(self, protoFile: FileDescriptorProto) -> list[str]:
        pkg = self.options["java_package"]
        importFlow = "import kotlinx.coroutines.flow."
        lines = [
            "package " + pkg,
            "",
            importFlow + "Flow",
            importFlow + "map",
            "",
        ]
    
    def getFooter(self, protoFile: FileDescriptorProto) -> list[str]:
        return [""]
    
    def getTopLevelIndentation(self, protoFile: FileDescriptorProto) -> int:
        return 0

    def getServiceHeader(self, protoFile: FileDescriptorProto,
                         serv: ServiceDescriptorProto,
                         indentationLevel: int) -> list[str]:
        serviceName = self.getServiceName(protoFile, serv)
        indent = "    " * indentationLevel
        return [
            indent + "class %sAndroidGrpcClient (" % serviceName,
            indent + "    val stub: %sCoroutineStub" % serv.name,
            indent + "): %sGrpcClient {" % serviceName,
        ]

    def getServiceFooter(self, protoFile: FileDescriptorProto,
                         serv: ServiceDescriptorProto,
                         indentationLevel: int) -> list[str]:
        return ["}"]

    def getServiceMethod(self, protoFile: FileDescriptorProto,
                        serv: ServiceDescriptorProto,
                        method: MethodDescriptorProto,
                        indentationLevel: int) -> list[str]:
        indentationLevel += 1
        lines = self.getMethodSignature(protoFile,
                                        serv,
                                        method,
                                        indentationLevel)
        indent = "    " * indentationLevel
        lines[0] = indent + "override " + lines[0][4:]
        lines[-1] += " ="
        methodName = self.memberCase(method.name)
        if method.client_streaming:
            input = "map { it.toProto() }"
        else:
            input = "toProto()"
        if method.server_streaming:
            output = "map { it.toData() }"
        else:
            output = "toData()"
        lines.extend([
            indent + "    stub.%s(request.%s).%s" % \
                (methodName, input, output),
            ""
        ])
        return lines


class KMMGrpcIosMainGenerator(Generator):
    def __init__(self):
        super().__init__(baseName="kmm-grpc-ios-main")
    
    def processFile(self, protoFile: FileDescriptorProto,
                    response: CodeGeneratorResponse):
        self.options = self.getOptions(protoFile)
        self.namespace = self.getNamespace(protoFile)
        for generator in (
                KMMGrpcIosDelegateGenerator(self.namespace, self.options),
                KMMGrpcIosHelperGenerator(self.namespace, self.options),
        ):
            generator.processFile(protoFile, response)
    

def main():
    KMMGrpcIosMainGenerator().runOnStdinAndStdout()

if __name__ == "__main__":
    main()
